***** 브루트 포스 *****
모든 경우의 수를 다 계산해보는 것

1. 가능한 경우의 수는 몇가지인가?
2. 가능한 모든 방법을 다 만들어보기
3. 각각의 방법을 이용해 답을 구하기

시간복잡도 = 2번 * 3번

가능한 모든 방법 - 그냥 다 해보기
문제 2309
1번
문제 : 9개의 숫자 중, 합이 100이 되는 7개의 숫자를 구하라.
해결 : 9명 중 7명을 고르고, 그 합이 100이 되면 됨.
	    다시말해, 9명 중 포함되지 않은 2명을 고른 뒤 나머지 7명의 합 고려 
2번
경우의 수 : 9C2 = 9*8 / 2*1 = 36가지
			NC2 = N(N-1) / 2 = O(N**2)가지
3번
나머지 난쟁이의 키의 합을 고르는 시간 복잡도 : N-2번 -> O(N)

즉, 시간복잡도는 O(N**2) * O(N) = O(N**3)이 된다.


***** 다음 순열 ***** 문제 10972
1. A[i-1] < A[i]를 만족하는 가장 큰 i를 찾는다.
2. j >= i이면서 A[j] > A[i-1]를 만족하는 가장 큰 j를 찾는다.
3. A[i-1]과 A[j]를 바꾼다
4. A[i]부터 순열을 뒤집는다.

예) 7236541
723<6>5>4>1
1. 제일 뒤부터 >방향을 쭉 이어가다, <가 나오는 순간 그 뒤 6을 i로 지정, 3은 i-1이다.
2. 3(i-1)보다 크면서 가장 작은 j를 6뒷쪽부터(i이상)찾는다. 이 경우에는 4.
3. 3(i-1)과 4(j)를 바꾼다. 7246531
4. i부터 순열을 뒤집는다. 7241356

시간복잡도
1번 O(N), 2번 O(N), 3번 O(1), 4번 O(N)
서로 모두 독립적인 단계기 때문에 O(N)

** 팩토리얼 ** 문제 10819
모든 순열을 만드는데 걸리는 시간 : 다음순열 * N! = O(N*N!)

***** 다이나믹 프로그래밍(DP) *****
큰 문제를 작은 문제로 나눠서 푸는 알고리즘.

두 가지 속성을 만족해야 DP로 풀 수 있다.
1. 작은문제(부분문제)가  겹쳐야 함.(중복되어야 함)
2. 최적 부분 구조

2번 예시 )
서울, 대전, 대구, 부산이 있고, 서울에서 부산으로 가는 가장 최적의 길은 서울 -> 대전 -> 대구 -> 부산이다. 이 때, 대전에서 부산으로 가는 최적의 길은  대전 -> 대구 -> 부산이고, 대구에서 부산을 가는 최적의 길은 대구 -> 부산이다.

따라서, DP는
각 문제(부분 문제)는 한 번만 풀어야 한다.
Optimal Substructure를 만족하기 때문에, 같은 문제는 구할 떄마다 정답이 같다.
따라서, 정답을 한 번 구했으면, 정답을 어딘가에 메모해놓는다.
이런 메모하는 것을 코드의 구현에서는 배열에 저장하는 것으로 할 수 있다. 

유클리드 호제법 - 1735
